# -*- coding: utf-8 -*-
"""Connect Four.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vNJRwI0vNYzI-rUlgGul8YRY6MxwpXXm

***All new connect four***
"""

import threading
import time
import selenium
from selenium.webdriver.common.by import By
from selenium import webdriver
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support.ui import Select

driver = webdriver.Safari()
driver.get('http://connect4.ist.tugraz.at:8080')

chooseAIplayer = driver.find_element_by_id("optionsaib")
chooseAIplayer.click()

chooseAIlevel = Select(driver.find_element_by_id("optionsaiblevel"))
chooseAIlevel.select_by_value('perfect') # perfect / justwin / random

debug = False

def push(col,chip,state):
    if len(state[col]) >= 6:
        return False
    state[col].append(chip)

def check_window(state,chip,i,j):
    state = [s+['o']*(7-len(s)) for s in state]
    # print(state)
    max_count = 0
    count = 0
    if i <= 3:
        count = 0
        for col in range(4):
            if state[i+col][j] == chip:
                count += 1
            elif state[i+col][j] != 'o':
                count = 0
                break
        if count == 4:
            return (i,j,4)
    if count > max_count:
        max_count = count
    if j >= 3:
        count = 0
        for row in range(4):
            if state[i][j-row] == chip:
                count += 1
            elif state[i][j-row] != 'o':
                count = 0
                break
        if count == 4:
            return (i,j,4)
    if count > max_count:
        max_count = count

    if i <= 3 and j >= 3:
        count = 0
        for k in range(4):
            if state[i+k][j-k] == chip:
                count += 1
            elif state[i+k][j-k] != 'o':
                count = 0
                break
        if count == 4:
            return (i,j,4)
    if count > max_count:
        max_count = count
    
    if i <= 3 and j <= 2:
        count = 0
        for k in range(4):
            if state[i+k][j+k] == chip:
                count += 1
            elif state[i+k][j+k] != 'o':
                count = 0
                break
        if count == 4:
            return (i,j,4)
    if count > max_count:
        max_count = count
        
    # if max_count == 3 and (j == 0 or state[i][j-1] != 'o') and state[i][j] == 'o':
    #    return (i,j,3)
    # if max_count == 3 and state[i][j-1] == 'o':
    #    return (i,j,3)
    return (i,j,max_count)

def utility(state,chip):
    ret=is_win(state,chip)
    if debug: show_state(state)
    if debug: print(ret)
    if chip == 'B':
        return ret[2]
    return -ret[2]
    

def is_win(state,chip):
    max = -1
    for i in range(7):
        for j in range(6):
            ret=check_window(state,chip,i,j)
            if ret[2] > max:
                max = ret[2]
                ans = ret
    return ans

def show_state(state):
    print()
    state = [s+['o']*(7-len(s)) for s in state]
    for r in range(5,-1,-1):
        str_out = ''
        for c in range(7):
            str_out += state[c][r]
        print(str_out)
    print('1234567')
    # print(state)

max_depth = 12

def min_value_function(state,a,b,level):
    # just pushed black
    if is_win(state,'B')[2] == 4:
        return 4
    if level >= max_depth:
        if debug: print('Cutoff',state)
        ret_u = utility(state,'B')
        if debug: print('Utility',ret)
        return ret_u
    v=100
    for i in range(7):
        if len(state[i]) == 6:
            continue
        new_state = tuple([list(new_col) for new_col in state])
        push(i,'W',new_state)
        v = min(v,max_value_function(new_state,a,b,level+1))
        if v <= a:
            return v
        if b == 10:
            b = v
        else:
            b = min(b,v)
    return v

def max_value_function(state,a,b,level):
    # just pushed white
    if is_win(state,'W')[2] == 4:
        return -4
    v=-100
    # if black can win
    for i in range(7):
        if len(state[i]) == 6:
            continue
        new_state = tuple([list(new_col) for new_col in state])
        push(i,'B',new_state)
        if is_win(new_state,'B')[2] == 4:
            return 4
    for i in range(7):
        if len(state[i]) == 6:
            continue
        new_state = tuple([list(new_col) for new_col in state])
        push(i,'B',new_state)
        v = max(v,min_value_function(new_state,a,b,level+1))
        if v >= b: 
            return v # ถ้ามากกว่าเท่ากับก็ returnเลยไม่คิดต่อ 
        if a == -10:
            a = v
        else:
            a = max(a,v) # set new alpha
    return v

def alpha_beta_decision(state):
    global max_depth
    s_res = sum([len(c) for c in list(state)])
    if s_res == 1:
        ind = 0
        for c in list(state):
            if len(c) == 1:
                if ind == 0:
                    return 1
                else:
                    return ind-1
            ind += 1
    elif s_res == 0:
        return 3
    if s_res < 5:
        max_depth = 4
    elif s_res < 12:
        max_depth = 6
    elif s_res < 24:
        max_depth = 8
    else:
        max_depth = 10
    max_value = -100
    a,b=-10,10
    min_score=[]
    count_win = 0
    count_lose = 0
    for i in range(7):
        if len(state[i]) == 6:
            continue
        new_state = tuple([list(new_col) for new_col in state])
        push(i,'B',new_state)
        ret=min_value_function(new_state,a,b,0)
        min_score.append(ret)
        if debug: print('MiniMax Value',ret)
        if debug: show_state(new_state)
        if ret > max_value:
            max_value=ret
            action = i
        if ret == 4:
            count_win += 1
        elif ret == -4:
            count_lose += 1
    if count_win >= 1:
        print('From my calculation, I will win')
    elif count_lose == 7:
        print('From my calculation, you will win')
    print(min_score,action)
    return action

def count_down_thread():
    print('\n5..')
    for i in range(4,-1,-1):
      time.sleep(1)
      if terminate_flag:
        break
      print(str(i)+'..')
    print()

is_white_turn = False
state = ([],[],[],[],[],[],[])
#state=[['B', 'B', 'B','W'], [], ['W', 'W','B'], ['B', 'W','B'], ['W','W'], ['W'], []]
i = 2
show_state(state)
while sum([len(c) for c in list(state)]) != 42:
    if is_white_turn:
        wait = WebDriverWait(driver, 15)
        xarg = "//*[@id='history']/li["+str(i)+"]"
        wait.until(EC.presence_of_element_located((By.XPATH, xarg)))
        hist = driver.find_element_by_xpath(xarg)
        hlist = hist.text.split()
        # print(hlist)
        # print(hlist[4])
        c = int(hlist[4])
        # c = int(input('Please enter your column:'))
        if c==0:
            break
        while len(state[c-1]) == 6:
            print('You cannot put in column',c)
            c = int(input('Please enter your column:'))
        push(c-1,'W',state)
        i = i+2
        if is_win(state,'W')[2] == 4:
            print('You win!!!')
            show_state(state)
            break
        is_white_turn = False
    else:
        ct=threading.Thread(target=count_down_thread)
        terminate_flag=False
        ct.start()
        c = alpha_beta_decision(state)
        terminate_flag=True
        push(c,'B',state)
        chooseCol = driver.find_element_by_xpath("//table[@id='board']/tbody/tr[1]/td["+str(c+1)+"]")
        chooseCol.click()
        show_state(state)
        if is_win(state,'B')[2] == 4:
            print('I win!!!')
            break
        is_white_turn = True
